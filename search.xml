<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring AOP]]></title>
    <url>%2F2019%2F05%2F27%2F1%2F</url>
    <content type="text"><![CDATA[AOP ( 面向切面编程 ) 的概念1、什么是AOP?在单体架构下的软件开发中，一个大型项目通常是依照功能拆分成各个模块。但是如日志、安全和事务管理此类重要且繁琐的开发却没有必要参与到各个模块中，将这些功能与业务逻辑相关的模块分离就是面向切面编程所要解决的问题 AOP采取的是横向抽取机制，取代了传统纵向继承体系重复性代码。 2、那么何为软件的横向和纵向？从纵向结构来看就是我们软件的各个模块，它所负责的是软件的核心业务（如购商品购买、添加购物车等）；从横向来看的话，软件的各个模块之间又有所关联，其中会包含一些公共模块（例如日志、权限等）；这些公共模块可以存在于各个核心业务中，而AOP的处理将两者分离，使开发人员可以专注于核心业务的开发，提高了开发效率。 3、AOP 的作用及优势作用： 在程序运行期间，不修改源码对已有方法进行增强。 优势： 减少重复代码 提高开发效率 维护方便 4、AOP底层原理使用动态代理实现 （1）基于JDK的代理 适用于有接口情况，使用动态代理创建接口实现类代理对象 （2）基于CGLIB动态代理 适用于没有接口情况，使用动态代理创建类的子类代理对象 5、AOP术语 Advice (通知/增强): 所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。通知的类型：前置通知（事务前）,后置通知,异常通知,最终通知,环绕通知（整个invoke方法在执行就是环绕通知，环绕通知中有明确的切入方法调用）。 Joinpoint (连接点): 所谓连接点是指那些被拦截到的点。在 Spring 中,这些点指的是方法,因为 Spring 只支持方法类型的连接点。 Pointcut (切入点): 所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。（也就是被增强的方法。所有的切入点都是连接点，但所有的连接点不一定是切入点） Introduction (引介): 引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field。 Target(目标对象): 代理的目标对象。 Weaving (织入): 是指把增强应用到目标对象来创建新的代理对象的过程。 Spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 Proxy（代理）: 一个类被 AOP 织入增强后，就产生一个结果代理类。 Aspect(切面): 是切入点和通知（引介）的结合。 6、Spring中基于 xml 的 AOP 配置步骤 把通知 Bean 也交给 Spring 来管理 使用 aop : config 标签来表明开始 AOP 的设置 使用 aop : aspect 标签配置切面 id 属性：是给切面提供一个唯一标识 ref 属性：是指定通知类 Bean 的 id 在 aop : aspect 标签的内部使用对应标签来配置通知的类型 aop : before 标识前置通知 method 属性：用于指定类中哪个放啊是前置通知 pointcut 属性：用于指定切入点表达式，该切入点表达式指的是对业务层中哪些方法增强 切入点表达式的写法： 关键字：execution ( 表达式 ) 表达式： 标准写法：访问修饰符 + 返回值 + 包名.类名.方法名（参数列表） 举例：public void com.guo.service.impl.IAccountServiceImpl.saveAccount ( ) 全通配写法：* *..*.*(..) 访问修饰符可以省略 返回值可以使用通配符，表示任意返回值* com.guo.service.impl.AccountServiceImpl.saveAccount() 包名可以使用通配符，表示任意包，但是有几级包就需要写几个 *. 包名可以使用 .. 表示当前包和子包* *..AccountServiceImpl.saveAccount() 类名和方法名都可以使用 来实现通配` ...*()` 参数列表： 可以直接使写数据类型： 基本类型直接写名称（如 int ）* *..*.*(int) 引用类型写包名.类名的方式 （如 java.lang.String ） 可以使用通配符表四任意类型，但是必须有参数 可以使用 .. 表示有无参数即可，有参数可以是任意类型 实际开发中切入点表达式的通常写法： 切到业务层类实现下的所有方法：* com.guo.service.impl.*.*(..) 配置切入点表达式（aop : pointcut）： id属性用于指定表达式的唯一标识，expression属性用于指定表达式内容 此标签写在 aop : aspect 标签内部只能当前切面使用，在其外部则所有切面可用 Spring常用通知类型 前置通知（aop : before）：在切入点方法执行之前执行 后置通知（aop : after-returning）：在切入点方法正常执行之后执行，它和异常通知永远只能执行一个 异常通知（aop : after-throwing）：在切入点方法执行产生异常之后执行，它和后置通知永远只能执行一个 最终通知（aop : after）：无论切入点方法是否正常执行它都会在其后面执行 环绕通知]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring依赖注入]]></title>
    <url>%2F2019%2F05%2F24%2F1%2F</url>
    <content type="text"><![CDATA[spring依赖注入（一）、概述 能注入的数据： 基本类型和 String 其他 bean 类型（在配置文件中或者注解中配置过的bean） 复杂类型/集合类型 IOC的作用：减低程序间的耦合（即依赖关系） 在当前类需要用到其他类的对象，由 Spring 为我们提供，而我们在配置文件中说明依赖关系的维护，这种方式就称为依赖注入。 （二）、注入方式第一种：使用构造函数提供使用的标签：constructor-arg 标签所在位置：bean 标签的内部 标签中的属性： type : 用于指定要注入的数据类型，该类型也是构造函数中某个或某些参数的类型 index : 用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引的位置时从0开始 name(常用) : 用于指定给构造函数中指定名称的参数赋值 value : 用于提供基本类型和String类型的数据 ref : 用于指定其他的bean类型数据。它指的就是在spring的IOC核心容器出现过的bean对象 特点：在获取 bean 对象时，注入数据是必须的操作，否则无法操作成功 弊端：改变了 bean 对象的实例化方式，使我们在用不到这些数据的情况下也必须提供带参构造函数，因此开发中较少使用此方法，除非避无可避 例： 1234567891011121314151617public class AccountServiceImpl implements IAccountService &#123; // 如果时经常变化的数据不适用于依赖注入，此处仅为演示 private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name, Integer age, Date birthday)&#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(&quot;service中的saveaccount()执行了&quot;); &#125;&#125; 测试类： 1234567public static void main(String[] args) &#123; //1.获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); //2.根据id获取Bean对象 IAccountService as = (IAccountService)ac.getBean(&quot;accountService&quot;); as.saveAccount(); &#125; 配置如下： 123456&lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt; &lt;constructor-arg name = &quot;name&quot; value=&quot;taylor&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name = &quot;age&quot; value = &quot;23&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name = &quot;birthday&quot; ref = &quot;now&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;bean id = &quot;now&quot; class = &quot;java.util.Date&quot;&gt;&lt;/bean&gt; 第二种：使用 set 方法提供（更常用的方式）使用的标签：property 出现的位置：bean 标签的内部 标签的属性： name : 用于指定注入时所使用的 set 方法 value : 用于提供基本类型和 String 类型的数据 ref : 用于指定其他的bean类型数据，它指的就是在 Spring 容器中出现过的bean对象 优势：创建对象时没有明确的限制，可以直接使用默认构造函数 弊端：如果有某个成员必须有值，是有可能 set 方法没有执行 基本类型和 String 的注入方式 业务层 1234567891011121314151617181920212223public class AccountServiceImpl implements IAccountService &#123; // 如果时经常变化的数据不适用于依赖注入，此处仅为演示 private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public void saveAccount() &#123; System.out.println(&quot;service中的saveaccount()执行了&quot; + name + &quot;,&quot; + age + &quot;,&quot; +birthday); &#125;&#125; 配置bean.xml 1234567&lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;name&quot; value =&quot;taylor&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt; &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id = &quot;now&quot; class = &quot;java.util.Date&quot;&gt;&lt;/bean&gt; 测试类同上 复杂集合类型的注入方式 用于给 List 结构集合注入的标签listarrayset 用于给map结构集合注入的标签mapproperties 结构相同，标签可以互换，因此开发中只要记住两组标签即可 编写实例：12345678910111213141516171819202122232425262728293031323334353637public class AccountServiceImpl implements IAccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String, String&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; public void saveAccount() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(myMap); System.out.println(mySet); System.out.println(myProps); &#125;&#125; 配置如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt; &lt;property name=&quot;myList&quot;&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;myStrs&quot;&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbbb&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;mySet&quot;&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbbb&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--以下两种方式等价--&gt; &lt;property name=&quot;myMap&quot;&gt; &lt;map&gt; &lt;!--以下两种配置方式都可以--&gt; &lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;testA&quot;&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;myProps&quot;&gt; &lt;props&gt; &lt;prop key=&quot;testB&quot;&gt;bbb&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 第三种：使用注解提供 如何使用？ 第一步：在类或方法的前面加上注解关键字 第二步：引入约束,注意此处约束多了xmlns:context… 第三步：添加配置文件，告知 Spring 在创建容器时要扫描的包，配置所需的标签不是在 bean 约束中，而是一个名称为context 的名称孔家和约束中,完整配置如下： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 有哪些注解？ 用于创建对象的作用：等同于 xml 配置文件中编写一个 标签 @Component形式：@Component(value=” “)/@Component(“ “) 作用：用于把当前类对象存入 Spring 容器中 属性： value : 用于指定 bean 的 id，当我们不写的时候，它的默认值是当前类名，且首字母改小写;当值只有一个的时候可以省略 以下三个注解的作用与 @Component 完全一样，它们是 Spring 提供的更明确的划分，使三层对象更加清晰 @Controller 用于表现层 @Service 用于业务层 @Repository 用于持久层 用于注入数据的作用：等同于在 标签中写一个 标签 @Autowired 作用：自动按照类型注入，只要容器中有唯一的一个 bean 对象类型和要注入的变量类型匹配， 就可以注入成功如果IOC容器中没有任何 bean 的类型和要注入的变量类型匹配，则报错出现位置：可以是变量上，也可以是方法上，细节：在使用注解注入时，set 方法就不是必须的了 @Qualifier 作用：在按照类型注入的基础上再按照名称注入，它在给类成员注入时不能单独使用，但是在给方法参数注入 时可以。 属性： value : 用于指定注入的 bean 的 id @Resource 作用：直接按照 bean 的 id 注入，可以直接使用 属性： name : 用于指定 bean 的 id 等同于@Autowired+@Qualifier 以上三个注入都只能注入其他 bean 类型的数据，而基本类型和 String 类型的数据无法使用上述注解实现。另外，集合类型的注入只能通过 xml 配置文件实现 @Value作用：用于注入基本类型和 String 类型的数据 属性： value : 用于指定数据的值，它可以使用 Spring 中 Spel (即spring的el表达式) Spel 的写法：${表达式} 用于改变范围的作用：等同于在 标签中使用 scope 属性 @Scope作用：用于指定 bean 的作用范围 属性： value : 指定范围的取值，同 xml 中值，常用为 singleton , prototype 和生命周期相关（了解）作用：等同于在标签中使用 init-method 和 destroy-method @PreDestory 作用：用于指定销毁方法 @Postcontrust 作用：用于指定初始化方法]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring入门]]></title>
    <url>%2F2019%2F05%2F23%2F1%2F</url>
    <content type="text"><![CDATA[spring入门案例知识点一、 ApplicationContext的三个常用实现类： ClassPathXmlApplicationContext： 它可以加载路径下的配置文件，要求配置文件必须在路径下，否则加载不了 1ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); FileSyetemXmlApplicationContext：它可以加载磁盘下任意路径下的配置文件（必须有访问权限）加载方式如下： 1ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;C:\\user\\greyson\\...&quot;) AnnotationConfigApplicationContext：它是用于读取注解创建容器的 二、 核心容器的两个接口引发出来的问题 ApplicationContext：它在创建核心容器时，创建对象采取的策略是采用立即加载的方式，也就是说，只要一读取完配置文件就马上创建配置文件中配置的对象 单例对象适用 开发中常采用此接口 BeanFactory: 它在构建核心容器时，创建对象的策略是采用延迟加载的方式，什么时候获取 id 对象了，什么时候就创建对象。 多例对象适用 Spring中Bean的装配与管理三种创建 bean 对象的方式 使用默认构造函数创建 在spring的配置文件中，使用 id 和 class 属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建 bean 对象，此时如果类中没有默认构造函数，则对象无法创建。 1&lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt; 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入 Spring容器）,如下 12345678/** *模拟一个工厂类，该类可能存在于jar包中，无法通过修改源码的方式来提供默认构造函数 */ public class InstanceFactory &#123; public IAccountService getAccountService() &#123; return new AccountServiceImpl(); &#125; &#125; 配置方式如下： 12&lt;bean id = &quot;instanceFactory&quot; class = &quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;/bean&gt; &lt;bean id = &quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt; 使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器），如下： 123456public class StaticFactory &#123; public static IAccountService getAccountService() &#123; return new AccountServiceImpl(); &#125;&#125; 配置方式如下： 1&lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt; bean 的作用范围调整 bean 标签的 scope 属性 作用：用于指定 bean 的作用范围 取值：常用的就是单例和多例 singletond : 单例的（default） prototype : 多例的 request : 作用于 web 应用的请求范围 session : 作用于 web 应用的会话范围 global-session : 作用于集群的会话范围（全局会话范围），当不是集群范围时，它就是 session bean对象的声明周期 单例对象： 出生：当容器创建时发生 活着：只要容器还在对象就一直活着 死亡：容器销毁，对象消亡 总结：单例对象的声明周期和容器相同 多例对象： 出生：当我们使用对象时 Spring 框架为我们创建 活着：对象只要是在使用过程中就活着 死亡：当对象长时间不用，且没有别的对象引用时，由 Java 的GC回收]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode---字符串]]></title>
    <url>%2F2019%2F04%2F13%2Fstring%2F</url>
    <content type="text"><![CDATA[字符串简介字符串实际上是一个 unicode 字符数组。 比较函数字符串有它自己的比较函数。 在C++中，我们可以使用 “==” 来比较两个字符串。 在Java中，我们可能无法使用 “==” 来比较两个字符串。当我们使用 “==” 时，它实际上会比较这两个对象是否是同一个对象。我们可以用equal()函数来比较两个字符串。 是否可变不可变意味着一旦字符串被初始化，你就无法改变它的内容。 在某些语言（如 C ++）中，字符串是可变的。 也就是说，你可以像在数组中那样修改字符串。在其他一些语言（如 Java）中，字符串是不可变的。 修改操作不可变字符串无法被修改。只修改其中的一个字符，也必须创建一个新的字符串。你应该非常小心字符串连接。在 Java 中，由于字符串是不可变的，因此在连接时首先为新字符串分配足够的空间，复制旧字符串中的内容并附加到新字符串。因此，总时间复杂度将是O(n2)。 解决方案如果你希望你的字符串是可变的，这里有一些替代方案： 如果你确实希望你的字符串是可变的，则可以将其转换为字符数组。 如果你经常必须连接字符串，最好使用一些其他的数据结构，如 StringBuilder 。 以下代码以 O(n) 的复杂度运行。 区别String、StringBuffer和StringBuilder String：字符串常量，即String对象一旦创建之后该对象是不可更改的，适用于少量的字符串操作的情况。 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况（线程不安全） StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况（线程安全） 运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String 二进制求和给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1:输入: a = “11”, b = “1” 输出: “100” 分析：每次截取最后一位，进行相加。 当和为2时，向前进1，置此位为0 和为3时（后位进了1，且此位是1+1），向前进1，置此位为1 和为0或1时，置此位为和 当最高位需要进1 123456789101112131415161718192021222324252627282930public String addBinary(String a, String b) &#123; String result =&quot;&quot;; int lengthA = a.length(); int lengthB = b.length(); int sum = 0; while (lengthA &gt; 0 || lengthB &gt; 0) &#123; if (lengthA &gt; 0) &#123; sum += Integer.parseInt(a.substring(lengthA-1,lengthA)); lengthA--; &#125; if (lengthB &gt; 0) &#123; sum += Integer.parseInt(b.substring(lengthB-1,lengthB)); lengthB--; &#125; if (sum == 2) &#123; result = &quot;0&quot;+result; sum = 1; &#125; else if (sum == 3) &#123; result = &quot;1&quot; + result; sum = 1; &#125; else &#123; result = (sum + &quot;&quot;) + result; sum = 0; &#125; &#125; if (sum == 1) &#123; result = &quot;1&quot; + result; &#125; return result; &#125; 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1:12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2:1234输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。` 说明:所有输入只包含小写字母 a-z 。 1234567891011121314151617public String longestCommonPrefix(String[] strs) &#123; int count = strs.length; String prefix = &quot;&quot;; if(count != 0)&#123; prefix = strs[0]; &#125; for (int i = 0; i &lt; count; i++) &#123; //关键代码，不断的从后往前截取字符串，然后与之相比，直到startsWith()返回true while (!strs[i].startsWith(prefix)) &#123; //startsWith() 方法用于检测字符串是否以指定的前缀开始 prefix = prefix.substring(0, prefix.length() - 1); //substring()截取字符串 &#125; &#125; return prefix; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Java</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode---二维数组]]></title>
    <url>%2F2019%2F04%2F13%2FdoubleArray%2F</url>
    <content type="text"><![CDATA[对角线遍历给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。 示例：1234567891011输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,4,7,5,3,6,8,9]解释:&#123;% asset_img diagonal_traverse.png %&#125; 分析:分析一下遍历顺序的特点，可以看出，对角线的方向跟索引和（行的索引值+列的索引值）的奇偶性有关，然后加上边界情况，遍历的路线大概就出来了。 具体可以分为以下几种情况： 索引和为偶数 1.元素在第一行，往右走 2.元素在最后一列，往下走 3.其他情况，往右上走 索引和为奇数： 1.元素在第一列，往下走 2.元素在最后一行，往右走 3.其他情况，往左下走 按照这个思路，写出的方法如下：1234567891011121314151617181920212223242526272829303132333435363738394041public int[] findDiagonalOrder(int[][] matrix) &#123; if (matrix.length == 0 || matrix[0].length == 0) &#123; return new int[0]; &#125; //m代表行数，n代表列数 int m = matrix.length; int n = matrix[0].length; int[] result = new int[m * n]; //r代表当前行，c代表当前列 int r = 0; int c = 0; for (int i = 0; i &lt; result.length; i++) &#123; result[i] = matrix[r][c]; if ((r + c) % 2 == 0) &#123;//索引和为偶数 if (c == n - 1) &#123; r++; //在最后一列，往下走 &#125; else if (r == 0) &#123; c++; //在第一行，往右走 &#125; else &#123; c++; r--; //往右上走 &#125; &#125; else &#123;//索引和为奇数 if (r == m - 1) &#123; c++; //元素在最后一行，往右走 &#125; else if (c == 0) &#123; r++; //元素在第一列，往下走 &#125; else &#123; r++; c--; //往左下走 &#125; &#125; &#125; return result; &#125; 螺旋矩阵给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例:输入:12345[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] 输出: [1,2,3,6,9,8,7,4,5] 分析：思路和上道题的思路大致相同，可分为上右下左依此遍历(此题特别考察边界条件)：12345上：遍历区间[c,n]右：遍历区间[r+1,m]下：遍历区间[c,n-1]左：遍历区间[r,m]遍历一遍之后，r++，c++，m--，n--，继续遍历，直到(r&gt;m || c&gt;n),停止遍历 由上述思路可写出如下代码：1234567891011121314151617181920212223242526272829public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (matrix.length == 0) &#123; return list; &#125; int r = 0, m = matrix.length - 1; int c = 0, n = matrix[0].length - 1; while (r &lt;= m &amp;&amp; c &lt;= n) &#123; for (int i = c; i &lt;= n; i++) list.add(matrix[r][i]); for (int j = r + 1; j &lt;= m; j++) list.add(matrix[j][n]); if (r &lt; m &amp;&amp; c &lt; n) &#123; for (int i = n - 1; i &gt; c; i--) list.add(matrix[m][i]); for (int j = m; j &gt; r; j--) list.add(matrix[j][c]); &#125; r++; m--; c++; n--; &#125; return list; &#125; 杨辉三角给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例:123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 分析：每行的第一个数和最后一个数为1。 中间第i个数 = 上一行第i-1个数 + 上一行第i个数 由思路可得出：123456789101112131415public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; outer = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; numRows; i++) &#123; List&lt;Integer&gt; inner = new ArrayList&lt;&gt;(); for (int j = 0; j &lt;= i; j++) &#123; if (j == 0 || j == i) &#123; inner.add(1); &#125;else &#123; inner.add(outer.get(i - 1).get(j) + outer.get(i - 1).get(j - 1)); &#125; &#125; outer.add(inner); &#125; return outer; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode---数组]]></title>
    <url>%2F2019%2F04%2F13%2Farray%2F</url>
    <content type="text"><![CDATA[1.寻找数组的中心索引给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。 我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例：输入: nums = [1, 7, 3, 6, 5, 6] 输出: 3 解释:索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。同时, 3 也是第一个符合要求的中心索引。 思路：1.先计算出数组各项之和sum 2.进行一个循环，leftSum+=num[i], sum-=num[i],当leftSum == sum时，返回此时索引，当循环结束时没有，则返回-1 详细代码：123456789101112131415public int pivotIndex(int[] nums) &#123; int sum = 0; for(int num : nums)&#123; sum +=num; &#125; int leftSum = 0; for(int i = 0; i &lt; nums.length; i++)&#123; sum = sum - nums[i]; if(leftSum == sum)&#123; return i; &#125; leftSum = leftSum + nums[i]; &#125; return -1; &#125; 2.至少是其他数字两倍的最大数在一个给定的数组nums中，总是存在一个最大元素 。 查找数组中的最大元素是否至少是数组中每个其他数字的两倍。 如果是，则返回最大元素的索引，否则返回-1。 示例：输入: nums = [3, 6, 1, 0] 输出: 1 解释: 6是最大的整数, 对于数组中的其他整数,6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1. 思路：1.首先找出数组中的最大值 2.然后遍历数组，判断这个数是否至少是其他数的二倍 详细代码：123456789101112131415public int dominantIndex(int[] nums) &#123; int max = 0; for(int i = 1; i &lt; nums.length; i++)&#123; if(nums[i] &gt; nums[max] )&#123; max = i; &#125; &#125; for (int j = 0; j &lt; nums.length; j++) &#123; if (j != max &amp;&amp; nums[max] &lt; 2 * nums[j] ) &#123; //进行判断 return -1; &#125; &#125; return max; &#125; 3.加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例：输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 情况：1.不需要进位，例：123 2.只需要，个位进一，例：129 3.连进多位，例：4599 4.高位进一，例：999 详细代码：1234567891011121314151617public int[] plusOne(int[] digits) &#123; int n = digits.length; for (int i = n - 1; i &gt;= 0; i--) &#123; if (digits[i] &lt; 9)&#123; //直接加一，无需进位 digits[i]++; return digits; &#125;else if (digits[i] == 9)&#123; //本位置为0 digits[i] = 0; &#125; &#125; //若最高位需进一，初始化一个长度为n+1的数组，高位为1 int[] result = new int[n + 1]; result[0] = 1; return result; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的Java分层项目Demo]]></title>
    <url>%2F2019%2F03%2F07%2F1%2F</url>
    <content type="text"><![CDATA[分层的记账项目项目简介 这是一个家庭记账软件，主要功能有查询账务、多条件组合查询账务、添加账务、编辑账务、删除账务，并且分为四层：View层、Controller层、Service层、Dao层。这个小项目主要训练的是对项目的分析能力和程序分层能力。 View层 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MainView &#123; private ZhangWuController controller = new ZhangWuController(); /* * 实现界面效果 * 接受用户输入 * */ public void run()&#123; Scanner sc = new Scanner(System.in); while (true)&#123; System.out.println(&quot;---------------管家婆家庭记账软件---------------&quot;); System.out.println(&quot;1.添加账务 2.编辑账务 3.删除账务 4.查询账务 5.退出系统&quot;); System.out.println(&quot;请输入要操作的功能序号[1-5]:&quot;); //接受用户输入 int choose = sc.nextInt(); switch (choose)&#123; case 1: //添加账务 addZhangWu(); break; case 2: //编辑账务 editZhangWu(); break; case 3: //删除账务 deleteZhangWu(); break; case 4: selectZhangwu(); break; case 5: System.out.println(&quot;bye&quot;); System.exit(0); break; default: System.out.println(&quot;输入有误，请重输&quot;); &#125; &#125; &#125; public void addZhangWu()&#123; System.out.println(&quot;选择的是添加账务功能，请输入一下内容&quot;); Scanner sc = new Scanner(System.in); System.out.println(&quot;输入分类名称：&quot;); String flname = sc.next(); System.out.println(&quot;输入金额：&quot;); double money = sc.nextDouble(); System.out.println(&quot;输入账户：&quot;); String zhanghu = sc.next(); System.out.println(&quot;输入日期：格式 XXXX-XX-XX&quot;); String createtime = sc.next(); System.out.println(&quot;输入具体描述：&quot;); String description = sc.next(); //zwid可设置为0，因为后面不接收zwid 省代码 也可以用set方法 ZhangWu zw = new ZhangWu(0, flname,money,zhanghu,createtime,description); controller.addZhangWu(zw); System.out.println(&quot;恭喜！添加成功！！&quot;); &#125; View作用： View层就是视图层，即项目中的界面 查询功能 Controller层 1234567891011121314151617181920212223 public class ZhangWuController &#123; private ZhangWuService service = new ZhangWuService(); public void addZhangWu(ZhangWu zw)&#123; service.addZhangWu(zw); &#125; public List&lt;ZhangWu&gt; selectAll()&#123; return service.selectAll(); &#125; public List&lt;ZhangWu&gt; select(String startDate, String endDate)&#123; return service.select(startDate, endDate); &#125; public void editZhangWu(ZhangWu zw) &#123; service.editZhangWu(zw); &#125; public void deleteZhangWu(int zwid) &#123; service.deleteZhangWu(zwid); &#125;&#125; Controller作用： 控制层, 获取界面上的数据,为界面设置数据; 将要实现的功能交给业务层处理 Service层 1234567891011121314151617181920212223 public class ZhangWuService &#123; private ZhangWuDao dao = new ZhangWuDao(); //由控制层调用 public void addZhangWu(ZhangWu zw)&#123; dao.addZhangWu(zw); &#125; public List&lt;ZhangWu&gt; selectAll()&#123; return dao.selectAll(); &#125; public List&lt;ZhangWu&gt; select(String startDate, String endDate)&#123; return dao.select(startDate, endDate); &#125; public void editZhangWu(ZhangWu zw) &#123; dao.editZhangWu(zw); &#125; public void deleteZhangWu(int zwid) &#123; dao.deleteZhangWu(zwid); &#125;&#125; service层作用: 业务层, 功能的实现, 与controller控制层和数据访问层DAO交互, 将对数据库的操作交给DAO数据访问层来处理。 Dao层12345678910111213141516public class ZhangWuDao &#123; private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource()); //查询数据库，有业务层调用 //所有结果集存储到Bean对象中，存储到集合中 public void addZhangWu(ZhangWu zw)&#123; try &#123; String sql = &quot;INSERT INTO gjp_zhangwu (flname,money,zhanghu,createtime,description) VALUES (?,?,?,?,?)&quot;; Object[] params = &#123;zw.getFlname(), zw.getMoney(), zw.getZhanghu(), zw.getCreatetime(), zw.getDescription()&#125;; qr.update(sql,params); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;账务添加失败&quot;); &#125; &#125;&#125; dao层作用: 数据访问层, 用来操作数据库表的数据]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java分层结构</tag>
      </tags>
  </entry>
</search>

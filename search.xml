<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode---二维数组]]></title>
    <url>%2F2019%2F04%2F13%2FdoubleArray%2F</url>
    <content type="text"><![CDATA[对角线遍历给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。 示例：1234567891011输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,4,7,5,3,6,8,9]解释:&#123;% asset_img diagonal_traverse.png %&#125; 分析:分析一下遍历顺序的特点，可以看出，对角线的方向跟索引和（行的索引值+列的索引值）的奇偶性有关，然后加上边界情况，遍历的路线大概就出来了。 具体可以分为以下几种情况： 索引和为偶数 1.元素在第一行，往右走 2.元素在最后一列，往下走 3.其他情况，往右上走 索引和为奇数： 1.元素在第一列，往下走 2.元素在最后一行，往右走 3.其他情况，往左下走 按照这个思路，写出的方法如下：1234567891011121314151617181920212223242526272829303132333435363738394041public int[] findDiagonalOrder(int[][] matrix) &#123; if (matrix.length == 0 || matrix[0].length == 0) &#123; return new int[0]; &#125; //m代表行数，n代表列数 int m = matrix.length; int n = matrix[0].length; int[] result = new int[m * n]; //r代表当前行，c代表当前列 int r = 0; int c = 0; for (int i = 0; i &lt; result.length; i++) &#123; result[i] = matrix[r][c]; if ((r + c) % 2 == 0) &#123;//索引和为偶数 if (c == n - 1) &#123; r++; //在最后一列，往下走 &#125; else if (r == 0) &#123; c++; //在第一行，往右走 &#125; else &#123; c++; r--; //往右上走 &#125; &#125; else &#123;//索引和为奇数 if (r == m - 1) &#123; c++; //元素在最后一行，往右走 &#125; else if (c == 0) &#123; r++; //元素在第一列，往下走 &#125; else &#123; r++; c--; //往左下走 &#125; &#125; &#125; return result; &#125; 螺旋矩阵给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例:输入:12345[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]] 输出: [1,2,3,6,9,8,7,4,5] 分析：思路和上道题的思路大致相同，可分为上右下左依此遍历(此题特别考察边界条件)：12345上：遍历区间[c,n]右：遍历区间[r+1,m]下：遍历区间[c,n-1]左：遍历区间[r,m]遍历一遍之后，r++，c++，m--，n--，继续遍历，直到(r&gt;m || c&gt;n),停止遍历 由上述思路可写出如下代码：1234567891011121314151617181920212223242526272829public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (matrix.length == 0) &#123; return list; &#125; int r = 0, m = matrix.length - 1; int c = 0, n = matrix[0].length - 1; while (r &lt;= m &amp;&amp; c &lt;= n) &#123; for (int i = c; i &lt;= n; i++) list.add(matrix[r][i]); for (int j = r + 1; j &lt;= m; j++) list.add(matrix[j][n]); if (r &lt; m &amp;&amp; c &lt; n) &#123; for (int i = n - 1; i &gt; c; i--) list.add(matrix[m][i]); for (int j = m; j &gt; r; j--) list.add(matrix[j][c]); &#125; r++; m--; c++; n--; &#125; return list; &#125; 杨辉三角给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例:123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 分析：每行的第一个数和最后一个数为1。 中间第i个数 = 上一行第i-1个数 + 上一行第i个数 由思路可得出：123456789101112131415public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; outer = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; numRows; i++) &#123; List&lt;Integer&gt; inner = new ArrayList&lt;&gt;(); for (int j = 0; j &lt;= i; j++) &#123; if (j == 0 || j == i) &#123; inner.add(1); &#125;else &#123; inner.add(outer.get(i - 1).get(j) + outer.get(i - 1).get(j - 1)); &#125; &#125; outer.add(inner); &#125; return outer; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode---数组]]></title>
    <url>%2F2019%2F04%2F13%2Farray%2F</url>
    <content type="text"><![CDATA[1.寻找数组的中心索引给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。 我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例：输入: nums = [1, 7, 3, 6, 5, 6] 输出: 3 解释:索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。同时, 3 也是第一个符合要求的中心索引。 思路：1.先计算出数组各项之和sum 2.进行一个循环，leftSum+=num[i], sum-=num[i],当leftSum == sum时，返回此时索引，当循环结束时没有，则返回-1 详细代码：123456789101112131415public int pivotIndex(int[] nums) &#123; int sum = 0; for(int num : nums)&#123; sum +=num; &#125; int leftSum = 0; for(int i = 0; i &lt; nums.length; i++)&#123; sum = sum - nums[i]; if(leftSum == sum)&#123; return i; &#125; leftSum = leftSum + nums[i]; &#125; return -1; &#125; 2.至少是其他数字两倍的最大数在一个给定的数组nums中，总是存在一个最大元素 。 查找数组中的最大元素是否至少是数组中每个其他数字的两倍。 如果是，则返回最大元素的索引，否则返回-1。 示例：输入: nums = [3, 6, 1, 0] 输出: 1 解释: 6是最大的整数, 对于数组中的其他整数,6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1. 思路：1.首先找出数组中的最大值 2.然后遍历数组，判断这个数是否至少是其他数的二倍 详细代码：123456789101112131415public int dominantIndex(int[] nums) &#123; int max = 0; for(int i = 1; i &lt; nums.length; i++)&#123; if(nums[i] &gt; nums[max] )&#123; max = i; &#125; &#125; for (int j = 0; j &lt; nums.length; j++) &#123; if (j != max &amp;&amp; nums[max] &lt; 2 * nums[j] ) &#123; //进行判断 return -1; &#125; &#125; return max; &#125; 3.加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例：输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 情况：1.不需要进位，例：123 2.只需要，个位进一，例：129 3.连进多位，例：4599 4.高位进一，例：999 详细代码：1234567891011121314151617public int[] plusOne(int[] digits) &#123; int n = digits.length; for (int i = n - 1; i &gt;= 0; i--) &#123; if (digits[i] &lt; 9)&#123; //直接加一，无需进位 digits[i]++; return digits; &#125;else if (digits[i] == 9)&#123; //本位置为0 digits[i] = 0; &#125; &#125; //若最高位需进一，初始化一个长度为n+1的数组，高位为1 int[] result = new int[n + 1]; result[0] = 1; return result; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>LeetCode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的Java分层项目Demo]]></title>
    <url>%2F2019%2F03%2F07%2F1%2F</url>
    <content type="text"><![CDATA[分层的记账项目项目简介 这是一个家庭记账软件，主要功能有查询账务、多条件组合查询账务、添加账务、编辑账务、删除账务，并且分为四层：View层、Controller层、Service层、Dao层。这个小项目主要训练的是对项目的分析能力和程序分层能力。 View层 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class MainView &#123; private ZhangWuController controller = new ZhangWuController(); /* * 实现界面效果 * 接受用户输入 * */ public void run()&#123; Scanner sc = new Scanner(System.in); while (true)&#123; System.out.println(&quot;---------------管家婆家庭记账软件---------------&quot;); System.out.println(&quot;1.添加账务 2.编辑账务 3.删除账务 4.查询账务 5.退出系统&quot;); System.out.println(&quot;请输入要操作的功能序号[1-5]:&quot;); //接受用户输入 int choose = sc.nextInt(); switch (choose)&#123; case 1: //添加账务 addZhangWu(); break; case 2: //编辑账务 editZhangWu(); break; case 3: //删除账务 deleteZhangWu(); break; case 4: selectZhangwu(); break; case 5: System.out.println(&quot;bye&quot;); System.exit(0); break; default: System.out.println(&quot;输入有误，请重输&quot;); &#125; &#125; &#125; public void addZhangWu()&#123; System.out.println(&quot;选择的是添加账务功能，请输入一下内容&quot;); Scanner sc = new Scanner(System.in); System.out.println(&quot;输入分类名称：&quot;); String flname = sc.next(); System.out.println(&quot;输入金额：&quot;); double money = sc.nextDouble(); System.out.println(&quot;输入账户：&quot;); String zhanghu = sc.next(); System.out.println(&quot;输入日期：格式 XXXX-XX-XX&quot;); String createtime = sc.next(); System.out.println(&quot;输入具体描述：&quot;); String description = sc.next(); //zwid可设置为0，因为后面不接收zwid 省代码 也可以用set方法 ZhangWu zw = new ZhangWu(0, flname,money,zhanghu,createtime,description); controller.addZhangWu(zw); System.out.println(&quot;恭喜！添加成功！！&quot;); &#125; View作用： View层就是视图层，即项目中的界面 查询功能 Controller层 1234567891011121314151617181920212223 public class ZhangWuController &#123; private ZhangWuService service = new ZhangWuService(); public void addZhangWu(ZhangWu zw)&#123; service.addZhangWu(zw); &#125; public List&lt;ZhangWu&gt; selectAll()&#123; return service.selectAll(); &#125; public List&lt;ZhangWu&gt; select(String startDate, String endDate)&#123; return service.select(startDate, endDate); &#125; public void editZhangWu(ZhangWu zw) &#123; service.editZhangWu(zw); &#125; public void deleteZhangWu(int zwid) &#123; service.deleteZhangWu(zwid); &#125;&#125; Controller作用： 控制层, 获取界面上的数据,为界面设置数据; 将要实现的功能交给业务层处理 Service层 1234567891011121314151617181920212223 public class ZhangWuService &#123; private ZhangWuDao dao = new ZhangWuDao(); //由控制层调用 public void addZhangWu(ZhangWu zw)&#123; dao.addZhangWu(zw); &#125; public List&lt;ZhangWu&gt; selectAll()&#123; return dao.selectAll(); &#125; public List&lt;ZhangWu&gt; select(String startDate, String endDate)&#123; return dao.select(startDate, endDate); &#125; public void editZhangWu(ZhangWu zw) &#123; dao.editZhangWu(zw); &#125; public void deleteZhangWu(int zwid) &#123; dao.deleteZhangWu(zwid); &#125;&#125; service层作用: 业务层, 功能的实现, 与controller控制层和数据访问层DAO交互, 将对数据库的操作交给DAO数据访问层来处理。 Dao层12345678910111213141516public class ZhangWuDao &#123; private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource()); //查询数据库，有业务层调用 //所有结果集存储到Bean对象中，存储到集合中 public void addZhangWu(ZhangWu zw)&#123; try &#123; String sql = &quot;INSERT INTO gjp_zhangwu (flname,money,zhanghu,createtime,description) VALUES (?,?,?,?,?)&quot;; Object[] params = &#123;zw.getFlname(), zw.getMoney(), zw.getZhanghu(), zw.getCreatetime(), zw.getDescription()&#125;; qr.update(sql,params); &#125; catch (SQLException e) &#123; e.printStackTrace(); throw new RuntimeException(&quot;账务添加失败&quot;); &#125; &#125;&#125; dao层作用: 数据访问层, 用来操作数据库表的数据]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java分层结构</tag>
      </tags>
  </entry>
</search>

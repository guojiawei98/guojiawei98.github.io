<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>琐事</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-24T09:37:41.518Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>guojiawei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring依赖注入</title>
    <link href="http://yoursite.com/2019/05/24/1/"/>
    <id>http://yoursite.com/2019/05/24/1/</id>
    <published>2019-05-24T06:41:25.000Z</published>
    <updated>2019-05-24T09:37:41.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring依赖注入"><a href="#spring依赖注入" class="headerlink" title="spring依赖注入"></a>spring依赖注入</h1><h2 id="（一）、概述"><a href="#（一）、概述" class="headerlink" title="（一）、概述"></a>（一）、概述</h2><ol><li><p>能注入的数据：</p><ul><li>基本类型和 String</li><li>其他 bean 类型（在配置文件中或者注解中配置过的bean）</li><li>复杂类型/集合类型</li></ul></li><li><p>IOC的作用：减低程序间的耦合（即依赖关系）</p><p> 在当前类需要用到其他类的对象，由 Spring 为我们提供，而我们在配置文件中说明依赖关系的维护，这种方式就称为依赖注入。</p></li></ol><h2 id="（二）、注入方式"><a href="#（二）、注入方式" class="headerlink" title="（二）、注入方式"></a>（二）、注入方式</h2><h3 id="第一种：使用构造函数提供"><a href="#第一种：使用构造函数提供" class="headerlink" title="第一种：使用构造函数提供"></a>第一种：使用构造函数提供</h3><p>使用的标签：constructor-arg</p><p>标签所在位置：bean 标签的内部</p><p>标签中的属性：</p><ul><li>type : 用于指定要注入的数据类型，该类型也是构造函数中某个或某些参数的类型</li><li>index : 用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引的位置时从0开始</li><li>name(常用) : 用于指定给构造函数中指定名称的参数赋值</li><li>value : 用于提供基本类型和String类型的数据</li><li>ref : 用于指定其他的bean类型数据。它指的就是在spring的IOC核心容器出现过的bean对象</li></ul><p>特点：在获取 bean 对象时，注入数据是必须的操作，否则无法操作成功</p><p>弊端：改变了 bean 对象的实例化方式，使我们在用不到这些数据的情况下也必须提供带参构造函数，因此开发中较少使用此方法，除非避无可避</p><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line">    // 如果时经常变化的数据不适用于依赖注入，此处仅为演示</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Date birthday;</span><br><span class="line"></span><br><span class="line">    public AccountServiceImpl(String name, Integer age, Date birthday)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void  saveAccount() &#123;</span><br><span class="line">        System.out.println(&quot;service中的saveaccount()执行了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        //1.获取核心容器对象</span><br><span class="line">        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line">        //2.根据id获取Bean对象</span><br><span class="line">        IAccountService as  = (IAccountService)ac.getBean(&quot;accountService&quot;);</span><br><span class="line">        as.saveAccount();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name = &quot;name&quot; value=&quot;taylor&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg name = &quot;age&quot; value = &quot;23&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg name = &quot;birthday&quot; ref = &quot;now&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;bean id = &quot;now&quot; class = &quot;java.util.Date&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="第二种：使用-set-方法提供（更常用的方式）"><a href="#第二种：使用-set-方法提供（更常用的方式）" class="headerlink" title="第二种：使用 set 方法提供（更常用的方式）"></a>第二种：使用 set 方法提供（更常用的方式）</h3><p>使用的标签：property</p><p>出现的位置：bean 标签的内部</p><p>标签的属性：</p><ul><li><p>name : 用于指定注入时所使用的 set 方法</p></li><li><p>value : 用于提供基本类型和 String 类型的数据</p></li><li><p>ref : 用于指定其他的bean类型数据，它指的就是在 Spring 容器中出现过的bean对象</p></li></ul><p>优势：创建对象时没有明确的限制，可以直接使用默认构造函数</p><p>弊端：如果有某个成员必须有值，是有可能 set 方法没有执行</p><ol><li>基本类型和 String 的注入方式</li></ol><p>业务层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line">    // 如果时经常变化的数据不适用于依赖注入，此处仅为演示</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Date birthday;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void  saveAccount() &#123;</span><br><span class="line">        System.out.println(&quot;service中的saveaccount()执行了&quot; + name + &quot;,&quot; + age + &quot;,&quot; +birthday);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置bean.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value =&quot;taylor&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id = &quot;now&quot; class = &quot;java.util.Date&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>测试类同上</p><ol start="2"><li>复杂集合类型的注入方式</li></ol><p>用于给 List 结构集合注入的标签<br>list<br>array<br>set</p><p>用于给map结构集合注入的标签<br>map<br>properties</p><p>结构相同，标签可以互换，因此开发中只要记住两组标签即可</p><p>编写实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line"></span><br><span class="line">    private String[] myStrs;</span><br><span class="line">    private List&lt;String&gt; myList;</span><br><span class="line">    private Set&lt;String&gt; mySet;</span><br><span class="line">    private Map&lt;String, String&gt; myMap;</span><br><span class="line">    private Properties myProps;</span><br><span class="line"></span><br><span class="line">    public void setMyStrs(String[] myStrs) &#123;</span><br><span class="line">        this.myStrs = myStrs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyList(List&lt;String&gt; myList) &#123;</span><br><span class="line">        this.myList = myList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMySet(Set&lt;String&gt; mySet) &#123;</span><br><span class="line">        this.mySet = mySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyMap(Map&lt;String, String&gt; myMap) &#123;</span><br><span class="line">        this.myMap = myMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMyProps(Properties myProps) &#123;</span><br><span class="line">        this.myProps = myProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void  saveAccount() &#123;</span><br><span class="line">        System.out.println(Arrays.toString(myStrs));</span><br><span class="line">        System.out.println(myList);</span><br><span class="line">        System.out.println(myMap);</span><br><span class="line">        System.out.println(mySet);</span><br><span class="line">        System.out.println(myProps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;myList&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;aaa&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;bbb&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=&quot;myStrs&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;aaa&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;bbbb&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=&quot;mySet&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;aaa&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;bbbb&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--以下两种方式等价--&gt;</span><br><span class="line">    &lt;property name=&quot;myMap&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;!--以下两种配置方式都可以--&gt;</span><br><span class="line">            &lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;entry key=&quot;testA&quot;&gt;</span><br><span class="line">                &lt;value&gt;bbb&lt;/value&gt;</span><br><span class="line">            &lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;property name=&quot;myProps&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;testB&quot;&gt;bbb&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="第三种：使用注解提供"><a href="#第三种：使用注解提供" class="headerlink" title="第三种：使用注解提供"></a>第三种：使用注解提供</h3><ol><li><p>如何使用？</p><p> 第一步：在类或方法的前面加上注解关键字</p><p> 第二步：引入约束,注意此处约束多了xmlns:context…</p><p> 第三步：添加配置文件，告知 Spring 在创建容器时要扫描的包，配置所需的标签不是在 bean 约束中，而是一个名称为context 的名称孔家和约束中,完整配置如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>有哪些注解？</p></li></ol><h4 id="用于创建对象的"><a href="#用于创建对象的" class="headerlink" title="用于创建对象的"></a>用于创建对象的</h4><p>作用：等同于 xml 配置文件中编写一个 标签</p><ul><li>@Component<br>形式：@Component(value=” “)/@Component(“ “)</li></ul><p>作用：用于把当前类对象存入 Spring 容器中</p><p>属性：</p><p>value : 用于指定 bean 的 id，当我们不写的时候，它的默认值是当前类名，且首字母改小写;当值只有一个的时候可以省略</p><p>以下三个注解的作用与 @Component 完全一样，它们是 Spring 提供的更明确的划分，使三层对象更加清晰</p><ul><li>@Controller 用于表现层</li><li>@Service 用于业务层</li><li>@Repository 用于持久层</li></ul><h4 id="用于注入数据的"><a href="#用于注入数据的" class="headerlink" title="用于注入数据的"></a>用于注入数据的</h4><p>作用：等同于在 标签中写一个 标签</p><ul><li>@Autowired</li></ul><p>作用：自动按照类型注入，只要容器中有唯一的一个 bean 对象类型和要注入的变量类型匹配， 就可以注入成功如果IOC容器中没有任何 bean 的类型和要注入的变量类型匹配，则报错<br>出现位置：可以是变量上，也可以是方法上，<br>细节：在使用注解注入时，set 方法就不是必须的了</p><ul><li>@Qualifier</li></ul><p>作用：在按照类型注入的基础上再按照名称注入，它在给类成员注入时不能单独使用，但是在给方法参数注入 时可以。</p><p>属性：</p><p>value : 用于指定注入的 bean 的 id</p><ul><li>@Resource</li></ul><p>作用：直接按照 bean 的 id 注入，可以直接使用</p><p>属性：</p><p>name : 用于指定 bean 的 id</p><p>等同于@Autowired+@Qualifier</p><p>以上三个注入都只能注入其他 bean 类型的数据，而基本类型和 String 类型的数据无法使用上述注解实现。另外，集合类型的注入只能通过 xml 配置文件实现</p><ul><li>@Value<br>作用：用于注入基本类型和 String 类型的数据</li></ul><p>属性：</p><p>value : 用于指定数据的值，它可以使用 Spring 中 Spel (即spring的el表达式)</p><p>Spel 的写法：${表达式}</p><h4 id="用于改变范围的"><a href="#用于改变范围的" class="headerlink" title="用于改变范围的"></a>用于改变范围的</h4><p>作用：等同于在 标签中使用 scope 属性</p><ul><li>@Scope<br>作用：用于指定 bean 的作用范围</li></ul><p>属性：</p><p>value : 指定范围的取值，同 xml 中值，常用为 singleton , prototype</p><p>和生命周期相关（了解）<br>作用：等同于在标签中使用 init-method 和 destroy-method</p><ul><li>@PreDestory</li></ul><p>作用：用于指定销毁方法</p><ul><li>@Postcontrust</li></ul><p>作用：用于指定初始化方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring依赖注入&quot;&gt;&lt;a href=&quot;#spring依赖注入&quot; class=&quot;headerlink&quot; title=&quot;spring依赖注入&quot;&gt;&lt;/a&gt;spring依赖注入&lt;/h1&gt;&lt;h2 id=&quot;（一）、概述&quot;&gt;&lt;a href=&quot;#（一）、概述&quot; class=&quot;
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>spring入门</title>
    <link href="http://yoursite.com/2019/05/23/1/"/>
    <id>http://yoursite.com/2019/05/23/1/</id>
    <published>2019-05-23T08:39:18.000Z</published>
    <updated>2019-05-24T07:37:29.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring入门案例"><a href="#spring入门案例" class="headerlink" title="spring入门案例"></a>spring入门案例</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>一、 ApplicationContext的三个常用实现类：</p><ul><li><p>ClassPathXmlApplicationContext： 它可以加载路径下的配置文件，要求配置文件必须在路径下，否则加载不了</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</span><br></pre></td></tr></table></figure></li><li><p>FileSyetemXmlApplicationContext：它可以加载磁盘下任意路径下的配置文件（必须有访问权限）加载方式如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = new FileSystemXmlApplicationContext(&quot;C:\\user\\greyson\\...&quot;)</span><br></pre></td></tr></table></figure></li><li><p>AnnotationConfigApplicationContext：它是用于读取注解创建容器的</p></li></ul><p>二、 核心容器的两个接口引发出来的问题</p><ul><li><p>ApplicationContext：它在创建核心容器时，创建对象采取的策略是采用立即加载的方式，也就是说，只要一读取完配置文件就马上创建配置文件中配置的对象</p><pre><code>单例对象适用开发中常采用此接口</code></pre></li><li><p>BeanFactory: 它在构建核心容器时，创建对象的策略是采用延迟加载的方式，什么时候获取 id 对象了，什么时候就创建对象。</p><pre><code>多例对象适用</code></pre></li></ul><h1 id="Spring中Bean的装配与管理"><a href="#Spring中Bean的装配与管理" class="headerlink" title="Spring中Bean的装配与管理"></a>Spring中Bean的装配与管理</h1><h2 id="三种创建-bean-对象的方式"><a href="#三种创建-bean-对象的方式" class="headerlink" title="三种创建 bean 对象的方式"></a>三种创建 bean 对象的方式</h2><ol><li><p>使用默认构造函数创建</p><p> 在spring的配置文件中，使用 id 和 class 属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建 bean 对象，此时如果类中没有默认构造函数，则对象无法创建。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入 Spring容器）,如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *模拟一个工厂类，该类可能存在于jar包中，无法通过修改源码的方式来提供默认构造函数</span><br><span class="line"> */</span><br><span class="line"> public class InstanceFactory &#123;</span><br><span class="line">     public IAccountService getAccountService() &#123;</span><br><span class="line">         return new AccountServiceImpl();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 配置方式如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;instanceFactory&quot; class = &quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;</span><br><span class="line"> &lt;bean id = &quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器），如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class StaticFactory &#123;</span><br><span class="line">    public  static IAccountService getAccountService() &#123;</span><br><span class="line"></span><br><span class="line">        return new AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 配置方式如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = &quot;accountService&quot; class = &quot;com.itheima.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="bean-的作用范围调整"><a href="#bean-的作用范围调整" class="headerlink" title="bean 的作用范围调整"></a>bean 的作用范围调整</h2></li><li><p>bean 标签的 scope 属性</p><p>作用：用于指定 bean 的作用范围</p><p>取值：常用的就是单例和多例</p><ul><li>singletond : 单例的（default）</li><li>prototype : 多例的</li><li>request : 作用于 web 应用的请求范围</li><li>session : 作用于 web 应用的会话范围</li><li>global-session : 作用于集群的会话范围（全局会话范围），当不是集群范围时，它就是 session</li></ul></li></ol><ol start="2"><li><p>bean对象的声明周期</p><p> 单例对象：</p><ul><li>出生：当容器创建时发生</li><li>活着：只要容器还在对象就一直活着</li><li>死亡：容器销毁，对象消亡</li><li><p>总结：单例对象的声明周期和容器相同</p><p>多例对象：</p></li><li>出生：当我们使用对象时 Spring 框架为我们创建</li><li>活着：对象只要是在使用过程中就活着</li><li>死亡：当对象长时间不用，且没有别的对象引用时，由 Java 的GC回收</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring入门案例&quot;&gt;&lt;a href=&quot;#spring入门案例&quot; class=&quot;headerlink&quot; title=&quot;spring入门案例&quot;&gt;&lt;/a&gt;spring入门案例&lt;/h1&gt;&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode---字符串</title>
    <link href="http://yoursite.com/2019/04/13/string/"/>
    <id>http://yoursite.com/2019/04/13/string/</id>
    <published>2019-04-13T08:04:40.000Z</published>
    <updated>2019-04-13T09:04:46.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h1><p>字符串实际上是一个 unicode 字符数组。</p><h4 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h4><p>字符串有它自己的比较函数。</p><p>在C++中，我们可以使用 “==” 来比较两个字符串。</p><p>在Java中，我们可能无法使用 “==” 来比较两个字符串。当我们使用  “==” 时，它实际上会比较这两个对象是否是同一个对象。我们可以用equal()函数来比较两个字符串。</p><h4 id="是否可变"><a href="#是否可变" class="headerlink" title="是否可变"></a>是否可变</h4><p>不可变意味着一旦字符串被初始化，你就无法改变它的内容。</p><p>在某些语言（如 C ++）中，字符串是可变的。 也就是说，你可以像在数组中那样修改字符串。<br>在其他一些语言（如  Java）中，字符串是不可变的。</p><h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><p>不可变字符串无法被修改。只修改其中的一个字符，也必须创建一个新的字符串。你应该非常小心字符串连接。在 Java 中，由于字符串是不可变的，因此在连接时首先为新字符串分配足够的空间，复制旧字符串中的内容并附加到新字符串。因此，总时间复杂度将是O(n2)。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>如果你希望你的字符串是可变的，这里有一些替代方案：</p><ol><li>如果你确实希望你的字符串是可变的，则可以将其转换为字符数组。</li><li>如果你经常必须连接字符串，最好使用一些其他的数据结构，如 StringBuilder 。 以下代码以 O(n) 的复杂度运行。</li></ol><h4 id="区别String、StringBuffer和StringBuilder"><a href="#区别String、StringBuffer和StringBuilder" class="headerlink" title="区别String、StringBuffer和StringBuilder"></a>区别String、StringBuffer和StringBuilder</h4><ol><li>String：字符串常量，即String对象一旦创建之后该对象是不可更改的，适用于少量的字符串操作的情况。</li><li>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况（线程不安全）</li><li>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况（线程安全）</li><li>运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</li></ol><hr><h3 id="二进制求和"><a href="#二进制求和" class="headerlink" title="二进制求和"></a>二进制求和</h3><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p><p>输入为非空字符串且只包含数字 1 和 0。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><p>输入: a = “11”, b = “1”</p><p>输出: “100”</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>每次截取最后一位，进行相加。</p><ol><li>当和为2时，向前进1，置此位为0</li><li>和为3时（后位进了1，且此位是1+1），向前进1，置此位为1</li><li>和为0或1时，置此位为和</li><li>当最高位需要进1</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public String addBinary(String a, String b) &#123;</span><br><span class="line">        String result =&quot;&quot;;</span><br><span class="line">        int lengthA = a.length();</span><br><span class="line">        int lengthB = b.length();</span><br><span class="line">        int sum = 0;</span><br><span class="line">        while (lengthA &gt; 0 || lengthB &gt; 0) &#123;</span><br><span class="line">            if (lengthA &gt; 0) &#123;</span><br><span class="line">                sum += Integer.parseInt(a.substring(lengthA-1,lengthA));</span><br><span class="line">                lengthA--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (lengthB &gt; 0) &#123;</span><br><span class="line">                sum += Integer.parseInt(b.substring(lengthB-1,lengthB));</span><br><span class="line">                lengthB--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sum == 2) &#123;</span><br><span class="line">                result = &quot;0&quot;+result;</span><br><span class="line">                sum = 1;</span><br><span class="line">            &#125; else if (sum == 3) &#123;</span><br><span class="line">                result = &quot;1&quot; + result;</span><br><span class="line">                sum = 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result = (sum + &quot;&quot;) + result;</span><br><span class="line">                sum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sum == 1) &#123;</span><br><span class="line">            result = &quot;1&quot; + result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 “”。</p><h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>说明:所有输入只包含小写字母 a-z 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        int count = strs.length;</span><br><span class="line">        String prefix = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        if(count != 0)&#123;</span><br><span class="line">            prefix = strs[0];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            //关键代码，不断的从后往前截取字符串，然后与之相比，直到startsWith()返回true</span><br><span class="line">            while (!strs[i].startsWith(prefix)) &#123;</span><br><span class="line">                //startsWith() 方法用于检测字符串是否以指定的前缀开始</span><br><span class="line">                prefix = prefix.substring(0, prefix.length() - 1);</span><br><span class="line">                //substring()截取字符串</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return prefix;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串简介&quot;&gt;&lt;a href=&quot;#字符串简介&quot; class=&quot;headerlink&quot; title=&quot;字符串简介&quot;&gt;&lt;/a&gt;字符串简介&lt;/h1&gt;&lt;p&gt;字符串实际上是一个 unicode 字符数组。&lt;/p&gt;
&lt;h4 id=&quot;比较函数&quot;&gt;&lt;a href=&quot;#比较函数&quot; 
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode---二维数组</title>
    <link href="http://yoursite.com/2019/04/13/doubleArray/"/>
    <id>http://yoursite.com/2019/04/13/doubleArray/</id>
    <published>2019-04-13T06:15:51.000Z</published>
    <updated>2019-04-13T07:50:59.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对角线遍历"><a href="#对角线遍历" class="headerlink" title="对角线遍历"></a>对角线遍历</h1><p>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出:  [1,2,4,7,5,3,6,8,9]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">&#123;% asset_img diagonal_traverse.png %&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h3><p>分析一下遍历顺序的特点，可以看出，对角线的方向跟索引和（行的索引值+列的索引值）的奇偶性有关，然后加上边界情况，遍历的路线大概就出来了。</p><p>具体可以分为以下几种情况：</p><p>索引和为偶数</p><pre><code>1.元素在第一行，往右走2.元素在最后一列，往下走3.其他情况，往右上走</code></pre><p>索引和为奇数：</p><pre><code>1.元素在第一列，往下走2.元素在最后一行，往右走3.其他情况，往左下走</code></pre><p>按照这个思路，写出的方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public int[] findDiagonalOrder(int[][] matrix) &#123;</span><br><span class="line">       if (matrix.length == 0 || matrix[0].length == 0) &#123;</span><br><span class="line">           return new int[0];</span><br><span class="line">       &#125;</span><br><span class="line">       //m代表行数，n代表列数</span><br><span class="line">       int m = matrix.length;</span><br><span class="line">       int n = matrix[0].length;</span><br><span class="line">       int[] result = new int[m * n];</span><br><span class="line">       //r代表当前行，c代表当前列</span><br><span class="line">       int r = 0;</span><br><span class="line">       int c = 0;</span><br><span class="line">       for (int i = 0; i &lt; result.length; i++) &#123;</span><br><span class="line">           result[i] = matrix[r][c];</span><br><span class="line">           if ((r + c) % 2 == 0) &#123;//索引和为偶数</span><br><span class="line">               if (c == n - 1) &#123;</span><br><span class="line">                   r++;</span><br><span class="line">               //在最后一列，往下走</span><br><span class="line">               &#125; else if (r == 0) &#123;</span><br><span class="line">                   c++;</span><br><span class="line">               //在第一行，往右走</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   c++;</span><br><span class="line">                   r--;</span><br><span class="line">               //往右上走</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;//索引和为奇数</span><br><span class="line">               if (r == m - 1) &#123;</span><br><span class="line">                   c++;</span><br><span class="line">               //元素在最后一行，往右走</span><br><span class="line">               &#125; else if (c == 0) &#123;</span><br><span class="line">                   r++;</span><br><span class="line">               //元素在第一列，往下走</span><br><span class="line">               &#125; else &#123; </span><br><span class="line">                   r++;</span><br><span class="line">                   c--;</span><br><span class="line">               //往左下走</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><p>输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>输出: [1,2,3,6,9,8,7,4,5]</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>思路和上道题的思路大致相同，可分为上右下左依此遍历(此题特别考察边界条件)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">上：遍历区间[c,n]</span><br><span class="line">右：遍历区间[r+1,m]</span><br><span class="line">下：遍历区间[c,n-1]</span><br><span class="line">左：遍历区间[r,m]</span><br><span class="line">遍历一遍之后，r++，c++，m--，n--，继续遍历，直到(r&gt;m || c&gt;n),停止遍历</span><br></pre></td></tr></table></figure></p><p>由上述思路可写出如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        if (matrix.length == 0) &#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        int r = 0, m = matrix.length - 1;</span><br><span class="line">        int c = 0, n = matrix[0].length - 1;</span><br><span class="line"></span><br><span class="line">        while (r &lt;= m &amp;&amp; c &lt;= n) &#123;</span><br><span class="line">            for (int i = c; i &lt;= n; i++)</span><br><span class="line">                list.add(matrix[r][i]);</span><br><span class="line"></span><br><span class="line">            for (int j = r + 1; j &lt;= m; j++)</span><br><span class="line">                list.add(matrix[j][n]);</span><br><span class="line"></span><br><span class="line">            if (r &lt; m &amp;&amp; c &lt; n) &#123;</span><br><span class="line">                for (int i = n - 1; i &gt; c; i--)</span><br><span class="line">                    list.add(matrix[m][i]);</span><br><span class="line"></span><br><span class="line">                for (int j = m; j &gt; r; j--)</span><br><span class="line">                    list.add(matrix[j][c]);</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">            m--;</span><br><span class="line">            c++;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h1><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p><img src="/2019/04/13/doubleArray/PascalTriangleAnimated2.gif"><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例:"></a>示例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><pre><code>每行的第一个数和最后一个数为1。中间第i个数 = 上一行第i-1个数 + 上一行第i个数 </code></pre><p>由思路可得出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; outer = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; numRows; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; inner = new ArrayList&lt;&gt;();</span><br><span class="line">            for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">                if (j == 0 || j == i) &#123;</span><br><span class="line">                    inner.add(1);</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    inner.add(outer.get(i - 1).get(j) + outer.get(i - 1).get(j - 1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            outer.add(inner);</span><br><span class="line">        &#125;</span><br><span class="line">        return outer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对角线遍历&quot;&gt;&lt;a href=&quot;#对角线遍历&quot; class=&quot;headerlink&quot; title=&quot;对角线遍历&quot;&gt;&lt;/a&gt;对角线遍历&lt;/h1&gt;&lt;p&gt;给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode---数组</title>
    <link href="http://yoursite.com/2019/04/13/array/"/>
    <id>http://yoursite.com/2019/04/13/array/</id>
    <published>2019-04-13T01:35:28.000Z</published>
    <updated>2019-04-13T07:48:02.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-寻找数组的中心索引"><a href="#1-寻找数组的中心索引" class="headerlink" title="1.寻找数组的中心索引"></a>1.寻找数组的中心索引</h1><p>给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。</p><p>我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>输入: nums = [1, 7, 3, 6, 5, 6]</p><p>输出: 3</p><p>解释:<br>索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。同时, 3 也是第一个符合要求的中心索引。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><pre><code>1.先计算出数组各项之和sum2.进行一个循环，leftSum+=num[i], sum-=num[i],当leftSum == sum时，返回此时索引，当循环结束时没有，则返回-1</code></pre><h3 id="详细代码："><a href="#详细代码：" class="headerlink" title="详细代码："></a>详细代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int pivotIndex(int[] nums) &#123;</span><br><span class="line">     int sum = 0;</span><br><span class="line">       for(int num : nums)&#123;</span><br><span class="line">           sum +=num;</span><br><span class="line">       &#125;</span><br><span class="line">       int leftSum = 0;</span><br><span class="line">       for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">           sum = sum - nums[i];</span><br><span class="line">           if(leftSum == sum)&#123;</span><br><span class="line">               return i;</span><br><span class="line">           &#125;</span><br><span class="line">           leftSum = leftSum + nums[i];</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="2-至少是其他数字两倍的最大数"><a href="#2-至少是其他数字两倍的最大数" class="headerlink" title="2.至少是其他数字两倍的最大数"></a>2.至少是其他数字两倍的最大数</h1><p>在一个给定的数组nums中，总是存在一个最大元素 。</p><p>查找数组中的最大元素是否至少是数组中每个其他数字的两倍。</p><p>如果是，则返回最大元素的索引，否则返回-1。</p><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><p>输入: nums = [3, 6, 1, 0]</p><p>输出: 1</p><p>解释: 6是最大的整数, 对于数组中的其他整数,<br>6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><pre><code>1.首先找出数组中的最大值2.然后遍历数组，判断这个数是否至少是其他数的二倍</code></pre><h3 id="详细代码：-1"><a href="#详细代码：-1" class="headerlink" title="详细代码："></a>详细代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int dominantIndex(int[] nums) &#123;</span><br><span class="line">       int max = 0;</span><br><span class="line">       for(int i = 1; i &lt; nums.length; i++)&#123;</span><br><span class="line">           if(nums[i] &gt; nums[max] )&#123;</span><br><span class="line">               max = i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int j = 0; j &lt; nums.length; j++) &#123;</span><br><span class="line">           if (j != max &amp;&amp; nums[max] &lt; 2 * nums[j] ) &#123;</span><br><span class="line">               //进行判断</span><br><span class="line">               return -1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="3-加一"><a href="#3-加一" class="headerlink" title="3.加一"></a>3.加一</h1><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><p>输入: [1,2,3]</p><p>输出: [1,2,4]</p><p>解释: 输入数组表示数字 123。</p><h3 id="情况："><a href="#情况：" class="headerlink" title="情况："></a>情况：</h3><pre><code>1.不需要进位，例：1232.只需要，个位进一，例：1293.连进多位，例：45994.高位进一，例：999</code></pre><h3 id="详细代码：-2"><a href="#详细代码：-2" class="headerlink" title="详细代码："></a>详细代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int[] plusOne(int[] digits) &#123;</span><br><span class="line">       int n = digits.length;</span><br><span class="line">       for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">           if (digits[i] &lt; 9)&#123;</span><br><span class="line">               //直接加一，无需进位</span><br><span class="line">               digits[i]++;</span><br><span class="line">               return digits;</span><br><span class="line">           &#125;else if (digits[i] == 9)&#123;</span><br><span class="line">               //本位置为0</span><br><span class="line">               digits[i] = 0;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //若最高位需进一，初始化一个长度为n+1的数组，高位为1</span><br><span class="line">       int[] result = new int[n + 1];</span><br><span class="line">       result[0] = 1;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-寻找数组的中心索引&quot;&gt;&lt;a href=&quot;#1-寻找数组的中心索引&quot; class=&quot;headerlink&quot; title=&quot;1.寻找数组的中心索引&quot;&gt;&lt;/a&gt;1.寻找数组的中心索引&lt;/h1&gt;&lt;p&gt;给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”
      
    
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简单的Java分层项目Demo</title>
    <link href="http://yoursite.com/2019/03/07/1/"/>
    <id>http://yoursite.com/2019/03/07/1/</id>
    <published>2019-03-07T02:25:19.000Z</published>
    <updated>2019-04-13T01:52:06.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分层的记账项目"><a href="#分层的记账项目" class="headerlink" title="分层的记账项目"></a>分层的记账项目</h1><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p> 这是一个家庭记账软件，主要功能有查询账务、多条件组合查询账务、添加账务、编辑账务、删除账务，并且分为四层：View层、Controller层、Service层、Dao层。这个小项目主要训练的是对项目的分析能力和程序分层能力。</p><h2 id="View层"><a href="#View层" class="headerlink" title="View层"></a>View层</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class MainView &#123;</span><br><span class="line">    private ZhangWuController controller = new ZhangWuController();</span><br><span class="line">    /*</span><br><span class="line">    * 实现界面效果</span><br><span class="line">    * 接受用户输入</span><br><span class="line">    * */</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            System.out.println(&quot;---------------管家婆家庭记账软件---------------&quot;);</span><br><span class="line">            System.out.println(&quot;1.添加账务　2.编辑账务　3.删除账务　4.查询账务　5.退出系统&quot;);</span><br><span class="line">            System.out.println(&quot;请输入要操作的功能序号[1-5]:&quot;);</span><br><span class="line">            //接受用户输入</span><br><span class="line">            int choose = sc.nextInt();</span><br><span class="line">            switch (choose)&#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    //添加账务</span><br><span class="line">                    addZhangWu();</span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    //编辑账务</span><br><span class="line">                    editZhangWu();</span><br><span class="line">                    break;</span><br><span class="line">                case 3:</span><br><span class="line">                    //删除账务</span><br><span class="line">                    deleteZhangWu();</span><br><span class="line">                    break;</span><br><span class="line">                case 4:</span><br><span class="line">                    selectZhangwu();</span><br><span class="line">                    break;</span><br><span class="line">                case 5:</span><br><span class="line">                    System.out.println(&quot;bye&quot;);</span><br><span class="line">                    System.exit(0);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    System.out.println(&quot;输入有误，请重输&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addZhangWu()&#123;</span><br><span class="line">        System.out.println(&quot;选择的是添加账务功能，请输入一下内容&quot;);</span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;输入分类名称：&quot;);</span><br><span class="line">        String flname = sc.next();</span><br><span class="line">        System.out.println(&quot;输入金额：&quot;);</span><br><span class="line">        double money = sc.nextDouble();</span><br><span class="line">        System.out.println(&quot;输入账户：&quot;);</span><br><span class="line">        String zhanghu = sc.next();</span><br><span class="line">        System.out.println(&quot;输入日期：格式 XXXX-XX-XX&quot;);</span><br><span class="line">        String createtime = sc.next();</span><br><span class="line">        System.out.println(&quot;输入具体描述：&quot;);</span><br><span class="line">        String description = sc.next();</span><br><span class="line">        //zwid可设置为0，因为后面不接收zwid 省代码 也可以用set方法</span><br><span class="line">        ZhangWu zw = new ZhangWu(0, flname,money,zhanghu,createtime,description);</span><br><span class="line">        controller.addZhangWu(zw);</span><br><span class="line">        System.out.println(&quot;恭喜！添加成功！！&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  <strong>View作用：</strong> View层就是视图层，即项目中的界面</p>  <img src="/2019/03/07/1/QQ图片20190307132040.jpg" title="This is an example image">  <center> 查询功能</center><hr><h2 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  public class ZhangWuController &#123;</span><br><span class="line">    private ZhangWuService service = new ZhangWuService();</span><br><span class="line"></span><br><span class="line">    public void addZhangWu(ZhangWu zw)&#123;</span><br><span class="line">        service.addZhangWu(zw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;ZhangWu&gt; selectAll()&#123;</span><br><span class="line">        return service.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;ZhangWu&gt; select(String startDate, String endDate)&#123;</span><br><span class="line">        return service.select(startDate, endDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void editZhangWu(ZhangWu zw) &#123;</span><br><span class="line">        service.editZhangWu(zw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteZhangWu(int zwid) &#123;</span><br><span class="line">        service.deleteZhangWu(zwid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>Controller作用：</strong> 控制层, 获取界面上的数据,为界面设置数据; 将要实现的功能交给业务层处理</p><hr><h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  public class ZhangWuService &#123;</span><br><span class="line">    private ZhangWuDao dao = new ZhangWuDao();</span><br><span class="line">    //由控制层调用</span><br><span class="line">    public void addZhangWu(ZhangWu zw)&#123;</span><br><span class="line">        dao.addZhangWu(zw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;ZhangWu&gt; selectAll()&#123;</span><br><span class="line">        return dao.selectAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;ZhangWu&gt; select(String startDate, String endDate)&#123;</span><br><span class="line">        return dao.select(startDate, endDate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void editZhangWu(ZhangWu zw) &#123;</span><br><span class="line">        dao.editZhangWu(zw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteZhangWu(int zwid) &#123;</span><br><span class="line">        dao.deleteZhangWu(zwid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>service层作用</strong>: 业务层, 功能的实现, 与controller控制层和数据访问层DAO交互, 将对数据库的操作交给DAO数据访问层来处理。</p><hr><h2 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ZhangWuDao &#123;</span><br><span class="line">    private QueryRunner qr = new QueryRunner(JDBCUtils.getDataSource());</span><br><span class="line">    //查询数据库，有业务层调用</span><br><span class="line">    //所有结果集存储到Bean对象中，存储到集合中</span><br><span class="line"></span><br><span class="line">    public void addZhangWu(ZhangWu zw)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;INSERT INTO gjp_zhangwu (flname,money,zhanghu,createtime,description) VALUES (?,?,?,?,?)&quot;;</span><br><span class="line">            Object[] params = &#123;zw.getFlname(), zw.getMoney(), zw.getZhanghu(), zw.getCreatetime(), zw.getDescription()&#125;;</span><br><span class="line">            qr.update(sql,params);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(&quot;账务添加失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dao层作用:</strong>  数据访问层, 用来操作数据库表的数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分层的记账项目&quot;&gt;&lt;a href=&quot;#分层的记账项目&quot; class=&quot;headerlink&quot; title=&quot;分层的记账项目&quot;&gt;&lt;/a&gt;分层的记账项目&lt;/h1&gt;&lt;h2 id=&quot;项目简介&quot;&gt;&lt;a href=&quot;#项目简介&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java分层结构" scheme="http://yoursite.com/tags/Java%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
